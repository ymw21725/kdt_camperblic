{"ast":null,"code":"import { isValidElement as t, useMemo as n, createElement as i } from \"react\";\nimport { filter as o, omit as e, isNumber as a } from \"lodash\";\nimport { absoluteAngleDegrees as r, radiansToDegrees as s, positionFromAngle as l, degreesToRadians as u, useTheme as h, useMotionConfig as d, useAnimatedPath as c } from \"@nivo/core\";\nimport f from \"lodash/omit\";\nimport { useSpring as y, animated as x } from \"@react-spring/web\";\nimport { jsxs as m, Fragment as p, jsx as g } from \"react/jsx-runtime\";\nfunction k() {\n  return k = Object.assign ? Object.assign.bind() : function (t) {\n    for (var n = 1; n < arguments.length; n++) {\n      var i = arguments[n];\n      for (var o in i) Object.prototype.hasOwnProperty.call(i, o) && (t[o] = i[o]);\n    }\n    return t;\n  }, k.apply(this, arguments);\n}\nvar W = {\n    dotSize: 4,\n    noteWidth: 120,\n    noteTextOffset: 8,\n    animate: !0\n  },\n  v = function v(n) {\n    var i = typeof n;\n    return t(n) || \"string\" === i || \"function\" === i || \"object\" === i;\n  },\n  b = function b(t) {\n    var n = typeof t;\n    return \"string\" === n || \"function\" === n;\n  },\n  w = function w(t) {\n    return \"circle\" === t.type;\n  },\n  z = function z(t) {\n    return \"dot\" === t.type;\n  },\n  P = function P(t) {\n    return \"rect\" === t.type;\n  },\n  C = function C(t) {\n    var n = t.data,\n      i = t.annotations,\n      a = t.getPosition,\n      r = t.getDimensions;\n    return i.reduce(function (t, i) {\n      var s = i.offset || 0;\n      return [].concat(t, o(n, i.match).map(function (t) {\n        var n = a(t),\n          o = r(t);\n        return (w(i) || P(i)) && (o.size = o.size + 2 * s, o.width = o.width + 2 * s, o.height = o.height + 2 * s), k({}, e(i, [\"match\", \"offset\"]), n, o, {\n          size: i.size || o.size,\n          datum: t\n        });\n      }));\n    }, []);\n  },\n  O = function O(t, n, i, o) {\n    var e = Math.atan2(o - n, i - t);\n    return r(s(e));\n  },\n  S = function S(t) {\n    var n,\n      i,\n      o = t.x,\n      e = t.y,\n      r = t.noteX,\n      s = t.noteY,\n      h = t.noteWidth,\n      d = void 0 === h ? W.noteWidth : h,\n      c = t.noteTextOffset,\n      f = void 0 === c ? W.noteTextOffset : c;\n    if (a(r)) n = o + r;else {\n      if (void 0 === r.abs) throw new Error(\"noteX should be either a number or an object containing an 'abs' property\");\n      n = r.abs;\n    }\n    if (a(s)) i = e + s;else {\n      if (void 0 === s.abs) throw new Error(\"noteY should be either a number or an object containing an 'abs' property\");\n      i = s.abs;\n    }\n    var y = o,\n      x = e,\n      m = O(o, e, n, i);\n    if (w(t)) {\n      var p = l(u(m), t.size / 2);\n      y += p.x, x += p.y;\n    }\n    if (P(t)) {\n      var g = Math.round((m + 90) / 45) % 8;\n      0 === g && (x -= t.height / 2), 1 === g && (y += t.width / 2, x -= t.height / 2), 2 === g && (y += t.width / 2), 3 === g && (y += t.width / 2, x += t.height / 2), 4 === g && (x += t.height / 2), 5 === g && (y -= t.width / 2, x += t.height / 2), 6 === g && (y -= t.width / 2), 7 === g && (y -= t.width / 2, x -= t.height / 2);\n    }\n    var k = n,\n      v = n;\n    return (m + 90) % 360 > 180 ? (k -= d, v -= d) : v += d, {\n      points: [[y, x], [n, i], [v, i]],\n      text: [k, i - f],\n      angle: m + 90\n    };\n  },\n  j = function j(t) {\n    var i = t.data,\n      o = t.annotations,\n      e = t.getPosition,\n      a = t.getDimensions;\n    return n(function () {\n      return C({\n        data: i,\n        annotations: o,\n        getPosition: e,\n        getDimensions: a\n      });\n    }, [i, o, e, a]);\n  },\n  M = function M(t) {\n    var i = t.annotations;\n    return n(function () {\n      return i.map(function (t) {\n        return k({}, t, {\n          computed: S(k({}, t))\n        });\n      });\n    }, [i]);\n  },\n  T = function T(t) {\n    return n(function () {\n      return S(t);\n    }, [t]);\n  },\n  E = function E(t) {\n    var n = t.datum,\n      o = t.x,\n      e = t.y,\n      a = t.note,\n      r = h(),\n      s = d(),\n      l = s.animate,\n      u = s.config,\n      c = y({\n        x: o,\n        y: e,\n        config: u,\n        immediate: !l\n      });\n    return \"function\" == typeof a ? i(a, {\n      x: o,\n      y: e,\n      datum: n\n    }) : m(p, {\n      children: [r.annotations.text.outlineWidth > 0 && g(x.text, {\n        x: c.x,\n        y: c.y,\n        style: k({}, r.annotations.text, {\n          strokeLinejoin: \"round\",\n          strokeWidth: 2 * r.annotations.text.outlineWidth,\n          stroke: r.annotations.text.outlineColor\n        }),\n        children: a\n      }), g(x.text, {\n        x: c.x,\n        y: c.y,\n        style: f(r.annotations.text, [\"outlineWidth\", \"outlineColor\"]),\n        children: a\n      })]\n    });\n  },\n  I = function I(t) {\n    var i = t.points,\n      o = t.isOutline,\n      e = void 0 !== o && o,\n      a = h(),\n      r = n(function () {\n        var t = i[0];\n        return i.slice(1).reduce(function (t, n) {\n          return t + \" L\" + n[0] + \",\" + n[1];\n        }, \"M\" + t[0] + \",\" + t[1]);\n      }, [i]),\n      s = c(r);\n    if (e && a.annotations.link.outlineWidth <= 0) return null;\n    var l = k({}, a.annotations.link);\n    return e && (l.strokeLinecap = \"square\", l.strokeWidth = a.annotations.link.strokeWidth + 2 * a.annotations.link.outlineWidth, l.stroke = a.annotations.link.outlineColor, l.opacity = a.annotations.link.outlineOpacity), g(x.path, {\n      fill: \"none\",\n      d: s,\n      style: l\n    });\n  },\n  D = function D(t) {\n    var n = t.x,\n      i = t.y,\n      o = t.size,\n      e = h(),\n      a = d(),\n      r = a.animate,\n      s = a.config,\n      l = y({\n        x: n,\n        y: i,\n        radius: o / 2,\n        config: s,\n        immediate: !r\n      });\n    return m(p, {\n      children: [e.annotations.outline.outlineWidth > 0 && g(x.circle, {\n        cx: l.x,\n        cy: l.y,\n        r: l.radius,\n        style: k({}, e.annotations.outline, {\n          fill: \"none\",\n          strokeWidth: e.annotations.outline.strokeWidth + 2 * e.annotations.outline.outlineWidth,\n          stroke: e.annotations.outline.outlineColor,\n          opacity: e.annotations.outline.outlineOpacity\n        })\n      }), g(x.circle, {\n        cx: l.x,\n        cy: l.y,\n        r: l.radius,\n        style: e.annotations.outline\n      })]\n    });\n  },\n  L = function L(t) {\n    var n = t.x,\n      i = t.y,\n      o = t.size,\n      e = void 0 === o ? W.dotSize : o,\n      a = h(),\n      r = d(),\n      s = r.animate,\n      l = r.config,\n      u = y({\n        x: n,\n        y: i,\n        radius: e / 2,\n        config: l,\n        immediate: !s\n      });\n    return m(p, {\n      children: [a.annotations.outline.outlineWidth > 0 && g(x.circle, {\n        cx: u.x,\n        cy: u.y,\n        r: u.radius,\n        style: k({}, a.annotations.outline, {\n          fill: \"none\",\n          strokeWidth: 2 * a.annotations.outline.outlineWidth,\n          stroke: a.annotations.outline.outlineColor,\n          opacity: a.annotations.outline.outlineOpacity\n        })\n      }), g(x.circle, {\n        cx: u.x,\n        cy: u.y,\n        r: u.radius,\n        style: a.annotations.symbol\n      })]\n    });\n  },\n  R = function R(t) {\n    var n = t.x,\n      i = t.y,\n      o = t.width,\n      e = t.height,\n      a = t.borderRadius,\n      r = void 0 === a ? 6 : a,\n      s = h(),\n      l = d(),\n      u = l.animate,\n      c = l.config,\n      f = y({\n        x: n - o / 2,\n        y: i - e / 2,\n        width: o,\n        height: e,\n        config: c,\n        immediate: !u\n      });\n    return m(p, {\n      children: [s.annotations.outline.outlineWidth > 0 && g(x.rect, {\n        x: f.x,\n        y: f.y,\n        rx: r,\n        ry: r,\n        width: f.width,\n        height: f.height,\n        style: k({}, s.annotations.outline, {\n          fill: \"none\",\n          strokeWidth: s.annotations.outline.strokeWidth + 2 * s.annotations.outline.outlineWidth,\n          stroke: s.annotations.outline.outlineColor,\n          opacity: s.annotations.outline.outlineOpacity\n        })\n      }), g(x.rect, {\n        x: f.x,\n        y: f.y,\n        rx: r,\n        ry: r,\n        width: f.width,\n        height: f.height,\n        style: s.annotations.outline\n      })]\n    });\n  },\n  q = function q(t) {\n    var n = t.datum,\n      i = t.x,\n      o = t.y,\n      e = t.note,\n      a = T(t);\n    if (!v(e)) throw new Error(\"note should be a valid react element\");\n    return m(p, {\n      children: [g(I, {\n        points: a.points,\n        isOutline: !0\n      }), w(t) && g(D, {\n        x: i,\n        y: o,\n        size: t.size\n      }), z(t) && g(L, {\n        x: i,\n        y: o,\n        size: t.size\n      }), P(t) && g(R, {\n        x: i,\n        y: o,\n        width: t.width,\n        height: t.height,\n        borderRadius: t.borderRadius\n      }), g(I, {\n        points: a.points\n      }), g(E, {\n        datum: n,\n        x: a.text[0],\n        y: a.text[1],\n        note: e\n      })]\n    });\n  },\n  J = function J(t, n) {\n    n.forEach(function (n, i) {\n      var o = n[0],\n        e = n[1];\n      0 === i ? t.moveTo(o, e) : t.lineTo(o, e);\n    });\n  },\n  X = function X(t, n) {\n    var i = n.annotations,\n      o = n.theme;\n    0 !== i.length && (t.save(), i.forEach(function (n) {\n      if (!b(n.note)) throw new Error(\"note is invalid for canvas implementation\");\n      o.annotations.link.outlineWidth > 0 && (t.lineCap = \"square\", t.strokeStyle = o.annotations.link.outlineColor, t.lineWidth = o.annotations.link.strokeWidth + 2 * o.annotations.link.outlineWidth, t.beginPath(), J(t, n.computed.points), t.stroke(), t.lineCap = \"butt\"), w(n) && o.annotations.outline.outlineWidth > 0 && (t.strokeStyle = o.annotations.outline.outlineColor, t.lineWidth = o.annotations.outline.strokeWidth + 2 * o.annotations.outline.outlineWidth, t.beginPath(), t.arc(n.x, n.y, n.size / 2, 0, 2 * Math.PI), t.stroke()), z(n) && o.annotations.symbol.outlineWidth > 0 && (t.strokeStyle = o.annotations.symbol.outlineColor, t.lineWidth = 2 * o.annotations.symbol.outlineWidth, t.beginPath(), t.arc(n.x, n.y, n.size / 2, 0, 2 * Math.PI), t.stroke()), P(n) && o.annotations.outline.outlineWidth > 0 && (t.strokeStyle = o.annotations.outline.outlineColor, t.lineWidth = o.annotations.outline.strokeWidth + 2 * o.annotations.outline.outlineWidth, t.beginPath(), t.rect(n.x - n.width / 2, n.y - n.height / 2, n.width, n.height), t.stroke()), t.strokeStyle = o.annotations.link.stroke, t.lineWidth = o.annotations.link.strokeWidth, t.beginPath(), J(t, n.computed.points), t.stroke(), w(n) && (t.strokeStyle = o.annotations.outline.stroke, t.lineWidth = o.annotations.outline.strokeWidth, t.beginPath(), t.arc(n.x, n.y, n.size / 2, 0, 2 * Math.PI), t.stroke()), z(n) && (t.fillStyle = o.annotations.symbol.fill, t.beginPath(), t.arc(n.x, n.y, n.size / 2, 0, 2 * Math.PI), t.fill()), P(n) && (t.strokeStyle = o.annotations.outline.stroke, t.lineWidth = o.annotations.outline.strokeWidth, t.beginPath(), t.rect(n.x - n.width / 2, n.y - n.height / 2, n.width, n.height), t.stroke()), \"function\" == typeof n.note ? n.note(t, {\n        datum: n.datum,\n        x: n.computed.text[0],\n        y: n.computed.text[1],\n        theme: o\n      }) : (t.font = o.annotations.text.fontSize + \"px \" + o.annotations.text.fontFamily, t.textAlign = \"left\", t.textBaseline = \"alphabetic\", t.fillStyle = o.annotations.text.fill, t.strokeStyle = o.annotations.text.outlineColor, t.lineWidth = 2 * o.annotations.text.outlineWidth, o.annotations.text.outlineWidth > 0 && (t.lineJoin = \"round\", t.strokeText(n.note, n.computed.text[0], n.computed.text[1]), t.lineJoin = \"miter\"), t.fillText(n.note, n.computed.text[0], n.computed.text[1]));\n    }), t.restore());\n  };\nexport { q as Annotation, C as bindAnnotations, S as computeAnnotation, W as defaultProps, O as getLinkAngle, b as isCanvasNote, w as isCircleAnnotation, z as isDotAnnotation, P as isRectAnnotation, v as isSvgNote, X as renderAnnotationsToCanvas, j as useAnnotations, T as useComputedAnnotation, M as useComputedAnnotations };","map":{"version":3,"names":["W","dotSize","noteWidth","noteTextOffset","animate","v","n","i","t","b","w","type","z","P","C","data","annotations","a","getPosition","r","getDimensions","reduce","s","offset","concat","o","match","map","size","width","height","k","e","datum","O","Math","atan2","S","x","y","noteX","noteY","h","d","c","f","abs","Error","m","p","l","u","g","round","points","text","angle","j","M","computed","T","E","note","config","immediate","children","outlineWidth","style","strokeLinejoin","strokeWidth","stroke","outlineColor","I","isOutline","slice","link","strokeLinecap","opacity","outlineOpacity","path","fill","D","radius","outline","circle","cx","cy","L","symbol","R","borderRadius","rect","rx","ry","q","J","forEach","moveTo","lineTo","X","theme","length","save","lineCap","strokeStyle","lineWidth","beginPath","arc","PI","fillStyle","font","fontSize","fontFamily","textAlign","textBaseline","lineJoin","strokeText","fillText","restore","Annotation","bindAnnotations","computeAnnotation","defaultProps","getLinkAngle","isCanvasNote","isCircleAnnotation","isDotAnnotation","isRectAnnotation","isSvgNote","renderAnnotationsToCanvas","useAnnotations","useComputedAnnotation","useComputedAnnotations"],"sources":["D:\\shinjun_Final2\\camperblic\\src\\main\\frontend\\node_modules\\@nivo\\annotations\\src\\props.ts","D:\\shinjun_Final2\\camperblic\\src\\main\\frontend\\node_modules\\@nivo\\annotations\\src\\utils.ts","D:\\shinjun_Final2\\camperblic\\src\\main\\frontend\\node_modules\\@nivo\\annotations\\src\\compute.ts","D:\\shinjun_Final2\\camperblic\\src\\main\\frontend\\node_modules\\@nivo\\annotations\\src\\hooks.ts","D:\\shinjun_Final2\\camperblic\\src\\main\\frontend\\node_modules\\@nivo\\annotations\\src\\AnnotationNote.tsx","D:\\shinjun_Final2\\camperblic\\src\\main\\frontend\\node_modules\\@nivo\\annotations\\src\\AnnotationLink.tsx","D:\\shinjun_Final2\\camperblic\\src\\main\\frontend\\node_modules\\@nivo\\annotations\\src\\CircleAnnotationOutline.tsx","D:\\shinjun_Final2\\camperblic\\src\\main\\frontend\\node_modules\\@nivo\\annotations\\src\\DotAnnotationOutline.tsx","D:\\shinjun_Final2\\camperblic\\src\\main\\frontend\\node_modules\\@nivo\\annotations\\src\\RectAnnotationOutline.tsx","D:\\shinjun_Final2\\camperblic\\src\\main\\frontend\\node_modules\\@nivo\\annotations\\src\\Annotation.tsx","D:\\shinjun_Final2\\camperblic\\src\\main\\frontend\\node_modules\\@nivo\\annotations\\src\\canvas.ts"],"sourcesContent":["export const defaultProps = {\n    dotSize: 4,\n    noteWidth: 120,\n    noteTextOffset: 8,\n    animate: true,\n}\n","import {\n    AnnotationSpec,\n    CircleAnnotationSpec,\n    DotAnnotationSpec,\n    Note,\n    NoteCanvas,\n    NoteSvg,\n    RectAnnotationSpec,\n} from './types'\nimport { isValidElement } from 'react'\n\nexport const isSvgNote = <Datum>(note: Note<Datum>): note is NoteSvg<Datum> => {\n    const noteType = typeof note\n\n    return (\n        isValidElement(note) ||\n        noteType === 'string' ||\n        noteType === 'function' ||\n        noteType === 'object'\n    )\n}\n\nexport const isCanvasNote = <Datum>(note: Note<Datum>): note is NoteCanvas<Datum> => {\n    const noteType = typeof note\n\n    return noteType === 'string' || noteType === 'function'\n}\n\nexport const isCircleAnnotation = <Datum>(\n    annotationSpec: AnnotationSpec<Datum>\n): annotationSpec is CircleAnnotationSpec<Datum> => annotationSpec.type === 'circle'\n\nexport const isDotAnnotation = <Datum>(\n    annotationSpec: AnnotationSpec<Datum>\n): annotationSpec is DotAnnotationSpec<Datum> => annotationSpec.type === 'dot'\n\nexport const isRectAnnotation = <Datum>(\n    annotationSpec: AnnotationSpec<Datum>\n): annotationSpec is RectAnnotationSpec<Datum> => annotationSpec.type === 'rect'\n","import { filter, isNumber, omit } from 'lodash'\nimport {\n    radiansToDegrees,\n    absoluteAngleDegrees,\n    degreesToRadians,\n    positionFromAngle,\n} from '@nivo/core'\nimport { defaultProps } from './props'\nimport {\n    AnnotationPositionGetter,\n    AnnotationDimensionsGetter,\n    BoundAnnotation,\n    AnnotationMatcher,\n    AnnotationInstructions,\n} from './types'\nimport { isCircleAnnotation, isRectAnnotation } from './utils'\n\nexport const bindAnnotations = <\n    Datum = {\n        x: number\n        y: number\n    }\n>({\n    data,\n    annotations,\n    getPosition,\n    getDimensions,\n}: {\n    data: Datum[]\n    annotations: AnnotationMatcher<Datum>[]\n    getPosition: AnnotationPositionGetter<Datum>\n    getDimensions: AnnotationDimensionsGetter<Datum>\n}): BoundAnnotation<Datum>[] =>\n    annotations.reduce((acc: BoundAnnotation<Datum>[], annotation) => {\n        const offset = annotation.offset || 0\n\n        return [\n            ...acc,\n            ...filter<Datum>(data, annotation.match).map(datum => {\n                const position = getPosition(datum)\n                const dimensions = getDimensions(datum)\n\n                if (isCircleAnnotation(annotation) || isRectAnnotation(annotation)) {\n                    dimensions.size = dimensions.size + offset * 2\n                    dimensions.width = dimensions.width + offset * 2\n                    dimensions.height = dimensions.height + offset * 2\n                }\n\n                // acc.push({\n                //     ...omit(annotation, ['match', 'offset']),\n                //     ...position,\n                //     ...dimensions,\n                //     size: annotation.size || dimensions.size,\n                //     datum,\n                // } as any)\n                // return [\n                //     ...acc,\n                //     {\n                //         ...omit(annotation, ['match', 'offset']),\n                //         ...position,\n                //         ...dimensions,\n                //         size: annotation.size || dimensions.size,\n                //         datum,\n                //     },\n                // ]\n                return {\n                    ...omit(annotation, ['match', 'offset']),\n                    ...position,\n                    ...dimensions,\n                    size: annotation.size || dimensions.size,\n                    datum,\n                } as Required<BoundAnnotation<Datum>>\n            }),\n        ]\n\n        // return acc\n    }, [])\n\nexport const getLinkAngle = (\n    sourceX: number,\n    sourceY: number,\n    targetX: number,\n    targetY: number\n) => {\n    const angle = Math.atan2(targetY - sourceY, targetX - sourceX)\n\n    return absoluteAngleDegrees(radiansToDegrees(angle))\n}\n\nexport const computeAnnotation = <Datum>(\n    annotation: BoundAnnotation<Datum>\n): AnnotationInstructions => {\n    const {\n        x,\n        y,\n        noteX,\n        noteY,\n        noteWidth = defaultProps.noteWidth,\n        noteTextOffset = defaultProps.noteTextOffset,\n    } = annotation\n\n    let computedNoteX: number\n    let computedNoteY: number\n\n    if (isNumber(noteX)) {\n        computedNoteX = x + noteX\n    } else if (noteX.abs !== undefined) {\n        computedNoteX = noteX.abs\n    } else {\n        throw new Error(`noteX should be either a number or an object containing an 'abs' property`)\n    }\n\n    if (isNumber(noteY)) {\n        computedNoteY = y + noteY\n    } else if (noteY.abs !== undefined) {\n        computedNoteY = noteY.abs\n    } else {\n        throw new Error(`noteY should be either a number or an object containing an 'abs' property`)\n    }\n\n    let computedX = x\n    let computedY = y\n\n    const angle = getLinkAngle(x, y, computedNoteX, computedNoteY)\n\n    if (isCircleAnnotation<Datum>(annotation)) {\n        const position = positionFromAngle(degreesToRadians(angle), annotation.size / 2)\n        computedX += position.x\n        computedY += position.y\n    }\n\n    if (isRectAnnotation<Datum>(annotation)) {\n        const eighth = Math.round((angle + 90) / 45) % 8\n        if (eighth === 0) {\n            computedY -= annotation.height / 2\n        }\n        if (eighth === 1) {\n            computedX += annotation.width / 2\n            computedY -= annotation.height / 2\n        }\n        if (eighth === 2) {\n            computedX += annotation.width / 2\n        }\n        if (eighth === 3) {\n            computedX += annotation.width / 2\n            computedY += annotation.height / 2\n        }\n        if (eighth === 4) {\n            computedY += annotation.height / 2\n        }\n        if (eighth === 5) {\n            computedX -= annotation.width / 2\n            computedY += annotation.height / 2\n        }\n        if (eighth === 6) {\n            computedX -= annotation.width / 2\n        }\n        if (eighth === 7) {\n            computedX -= annotation.width / 2\n            computedY -= annotation.height / 2\n        }\n    }\n\n    let textX = computedNoteX\n    const textY = computedNoteY - noteTextOffset\n\n    let noteLineX = computedNoteX\n    const noteLineY = computedNoteY\n\n    if ((angle + 90) % 360 > 180) {\n        textX -= noteWidth\n        noteLineX -= noteWidth\n    } else {\n        noteLineX += noteWidth\n    }\n\n    return {\n        points: [\n            [computedX, computedY],\n            [computedNoteX, computedNoteY],\n            [noteLineX, noteLineY],\n        ] as [number, number][],\n        text: [textX, textY],\n        angle: angle + 90,\n    }\n}\n","import { useMemo } from 'react'\nimport { bindAnnotations, computeAnnotation } from './compute'\nimport {\n    AnnotationDimensionsGetter,\n    AnnotationMatcher,\n    AnnotationPositionGetter,\n    BoundAnnotation,\n} from './types'\n\n/**\n * Bind annotations to a dataset.\n */\nexport const useAnnotations = <Datum>({\n    data,\n    annotations,\n    getPosition,\n    getDimensions,\n}: {\n    data: Datum[]\n    annotations: AnnotationMatcher<Datum>[]\n    getPosition: AnnotationPositionGetter<Datum>\n    getDimensions: AnnotationDimensionsGetter<Datum>\n}) =>\n    useMemo(\n        () =>\n            bindAnnotations<Datum>({\n                data,\n                annotations,\n                getPosition,\n                getDimensions,\n            }),\n        [data, annotations, getPosition, getDimensions]\n    )\n\nexport const useComputedAnnotations = <Datum>({\n    annotations,\n}: {\n    annotations: BoundAnnotation<Datum>[]\n}) =>\n    useMemo(\n        () =>\n            annotations.map(annotation => ({\n                ...annotation,\n                computed: computeAnnotation<Datum>({\n                    ...annotation,\n                }),\n            })),\n        [annotations]\n    )\n\nexport const useComputedAnnotation = <Datum>(annotation: BoundAnnotation<Datum>) =>\n    useMemo(() => computeAnnotation<Datum>(annotation), [annotation])\n","import { createElement } from 'react'\nimport omit from 'lodash/omit'\nimport { useSpring, animated } from '@react-spring/web'\nimport { useTheme, useMotionConfig } from '@nivo/core'\nimport { NoteSvg } from './types'\n\nexport const AnnotationNote = <Datum,>({\n    datum,\n    x,\n    y,\n    note,\n}: {\n    datum: Datum\n    x: number\n    y: number\n    note: NoteSvg<Datum>\n}) => {\n    const theme = useTheme()\n    const { animate, config: springConfig } = useMotionConfig()\n\n    const animatedProps = useSpring({\n        x,\n        y,\n        config: springConfig,\n        immediate: !animate,\n    })\n\n    if (typeof note === 'function') {\n        return createElement(note, { x, y, datum })\n    }\n\n    return (\n        <>\n            {theme.annotations.text.outlineWidth > 0 && (\n                <animated.text\n                    x={animatedProps.x}\n                    y={animatedProps.y}\n                    style={{\n                        ...theme.annotations.text,\n                        strokeLinejoin: 'round',\n                        strokeWidth: theme.annotations.text.outlineWidth * 2,\n                        stroke: theme.annotations.text.outlineColor,\n                    }}\n                >\n                    {note}\n                </animated.text>\n            )}\n            <animated.text\n                x={animatedProps.x}\n                y={animatedProps.y}\n                style={omit(theme.annotations.text, ['outlineWidth', 'outlineColor'])}\n            >\n                {note}\n            </animated.text>\n        </>\n    )\n}\n","import { useMemo } from 'react'\nimport { animated } from '@react-spring/web'\nimport { useAnimatedPath, useTheme } from '@nivo/core'\n\nexport const AnnotationLink = ({\n    points,\n    isOutline = false,\n}: {\n    points: [number, number][]\n    isOutline?: boolean\n}) => {\n    const theme = useTheme()\n\n    const path = useMemo(() => {\n        const [firstPoint, ...otherPoints] = points\n\n        return otherPoints.reduce(\n            (acc, [x, y]) => `${acc} L${x},${y}`,\n            `M${firstPoint[0]},${firstPoint[1]}`\n        )\n    }, [points])\n\n    const animatedPath = useAnimatedPath(path)\n\n    if (isOutline && theme.annotations.link.outlineWidth <= 0) {\n        return null\n    }\n\n    const style = { ...theme.annotations.link }\n    if (isOutline) {\n        style.strokeLinecap = 'square'\n        style.strokeWidth =\n            theme.annotations.link.strokeWidth + theme.annotations.link.outlineWidth * 2\n        style.stroke = theme.annotations.link.outlineColor\n        style.opacity = theme.annotations.link.outlineOpacity\n    }\n\n    return <animated.path fill=\"none\" d={animatedPath} style={style} />\n}\n","import { useSpring, animated } from '@react-spring/web'\nimport { useMotionConfig, useTheme } from '@nivo/core'\n\nexport const CircleAnnotationOutline = ({ x, y, size }: { x: number; y: number; size: number }) => {\n    const theme = useTheme()\n    const { animate, config: springConfig } = useMotionConfig()\n\n    const animatedProps = useSpring({\n        x,\n        y,\n        radius: size / 2,\n        config: springConfig,\n        immediate: !animate,\n    })\n\n    return (\n        <>\n            {theme.annotations.outline.outlineWidth > 0 && (\n                <animated.circle\n                    cx={animatedProps.x}\n                    cy={animatedProps.y}\n                    r={animatedProps.radius}\n                    style={{\n                        ...theme.annotations.outline,\n                        fill: 'none',\n                        strokeWidth:\n                            theme.annotations.outline.strokeWidth +\n                            theme.annotations.outline.outlineWidth * 2,\n                        stroke: theme.annotations.outline.outlineColor,\n                        opacity: theme.annotations.outline.outlineOpacity,\n                    }}\n                />\n            )}\n            <animated.circle\n                cx={animatedProps.x}\n                cy={animatedProps.y}\n                r={animatedProps.radius}\n                style={theme.annotations.outline}\n            />\n        </>\n    )\n}\n","import { useSpring, animated } from '@react-spring/web'\nimport { useMotionConfig, useTheme } from '@nivo/core'\nimport { defaultProps } from './props'\n\nexport const DotAnnotationOutline = ({\n    x,\n    y,\n    size = defaultProps.dotSize,\n}: {\n    x: number\n    y: number\n    size?: number\n}) => {\n    const theme = useTheme()\n    const { animate, config: springConfig } = useMotionConfig()\n\n    const animatedProps = useSpring({\n        x,\n        y,\n        radius: size / 2,\n        config: springConfig,\n        immediate: !animate,\n    })\n\n    return (\n        <>\n            {theme.annotations.outline.outlineWidth > 0 && (\n                <animated.circle\n                    cx={animatedProps.x}\n                    cy={animatedProps.y}\n                    r={animatedProps.radius}\n                    style={{\n                        ...theme.annotations.outline,\n                        fill: 'none',\n                        strokeWidth: theme.annotations.outline.outlineWidth * 2,\n                        stroke: theme.annotations.outline.outlineColor,\n                        opacity: theme.annotations.outline.outlineOpacity,\n                    }}\n                />\n            )}\n            <animated.circle\n                cx={animatedProps.x}\n                cy={animatedProps.y}\n                r={animatedProps.radius}\n                style={theme.annotations.symbol}\n            />\n        </>\n    )\n}\n","import { useSpring, animated } from '@react-spring/web'\nimport { useMotionConfig, useTheme } from '@nivo/core'\n\nexport const RectAnnotationOutline = ({\n    x,\n    y,\n    width,\n    height,\n    borderRadius = 6,\n}: {\n    x: number\n    y: number\n    width: number\n    height: number\n    borderRadius?: number\n}) => {\n    const theme = useTheme()\n    const { animate, config: springConfig } = useMotionConfig()\n\n    const animatedProps = useSpring({\n        x: x - width / 2,\n        y: y - height / 2,\n        width,\n        height,\n        config: springConfig,\n        immediate: !animate,\n    })\n\n    return (\n        <>\n            {theme.annotations.outline.outlineWidth > 0 && (\n                <animated.rect\n                    x={animatedProps.x}\n                    y={animatedProps.y}\n                    rx={borderRadius}\n                    ry={borderRadius}\n                    width={animatedProps.width}\n                    height={animatedProps.height}\n                    style={{\n                        ...theme.annotations.outline,\n                        fill: 'none',\n                        strokeWidth:\n                            theme.annotations.outline.strokeWidth +\n                            theme.annotations.outline.outlineWidth * 2,\n                        stroke: theme.annotations.outline.outlineColor,\n                        opacity: theme.annotations.outline.outlineOpacity,\n                    }}\n                />\n            )}\n            <animated.rect\n                x={animatedProps.x}\n                y={animatedProps.y}\n                rx={borderRadius}\n                ry={borderRadius}\n                width={animatedProps.width}\n                height={animatedProps.height}\n                style={theme.annotations.outline}\n            />\n        </>\n    )\n}\n","import { useComputedAnnotation } from './hooks'\nimport { AnnotationNote } from './AnnotationNote'\nimport { AnnotationLink } from './AnnotationLink'\nimport { CircleAnnotationOutline } from './CircleAnnotationOutline'\nimport { DotAnnotationOutline } from './DotAnnotationOutline'\nimport { RectAnnotationOutline } from './RectAnnotationOutline'\nimport { BoundAnnotation } from './types'\nimport { isCircleAnnotation, isDotAnnotation, isRectAnnotation, isSvgNote } from './utils'\n\nexport const Annotation = <Datum,>(annotation: BoundAnnotation<Datum>) => {\n    const { datum, x, y, note } = annotation\n    const computed = useComputedAnnotation(annotation)\n\n    if (!isSvgNote(note)) {\n        throw new Error('note should be a valid react element')\n    }\n\n    return (\n        <>\n            <AnnotationLink points={computed.points} isOutline={true} />\n            {isCircleAnnotation(annotation) && (\n                <CircleAnnotationOutline x={x} y={y} size={annotation.size} />\n            )}\n            {isDotAnnotation(annotation) && (\n                <DotAnnotationOutline x={x} y={y} size={annotation.size} />\n            )}\n            {isRectAnnotation(annotation) && (\n                <RectAnnotationOutline\n                    x={x}\n                    y={y}\n                    width={annotation.width}\n                    height={annotation.height}\n                    borderRadius={annotation.borderRadius}\n                />\n            )}\n            <AnnotationLink points={computed.points} />\n            <AnnotationNote datum={datum} x={computed.text[0]} y={computed.text[1]} note={note} />\n        </>\n    )\n}\n","import { CompleteTheme } from '@nivo/core'\nimport { ComputedAnnotation } from './types'\nimport { isCanvasNote, isCircleAnnotation, isDotAnnotation, isRectAnnotation } from './utils'\n\nconst drawPoints = (ctx: CanvasRenderingContext2D, points: [number, number][]) => {\n    points.forEach(([x, y], index) => {\n        if (index === 0) {\n            ctx.moveTo(x, y)\n        } else {\n            ctx.lineTo(x, y)\n        }\n    })\n}\n\nexport const renderAnnotationsToCanvas = <Datum>(\n    ctx: CanvasRenderingContext2D,\n    {\n        annotations,\n        theme,\n    }: {\n        annotations: ComputedAnnotation<Datum>[]\n        theme: CompleteTheme\n    }\n) => {\n    if (annotations.length === 0) return\n\n    ctx.save()\n    annotations.forEach(annotation => {\n        if (!isCanvasNote(annotation.note)) {\n            throw new Error('note is invalid for canvas implementation')\n        }\n\n        if (theme.annotations.link.outlineWidth > 0) {\n            ctx.lineCap = 'square'\n            ctx.strokeStyle = theme.annotations.link.outlineColor\n            ctx.lineWidth =\n                theme.annotations.link.strokeWidth + theme.annotations.link.outlineWidth * 2\n            ctx.beginPath()\n            drawPoints(ctx, annotation.computed.points)\n            ctx.stroke()\n            ctx.lineCap = 'butt'\n        }\n\n        if (isCircleAnnotation(annotation) && theme.annotations.outline.outlineWidth > 0) {\n            ctx.strokeStyle = theme.annotations.outline.outlineColor\n            ctx.lineWidth =\n                theme.annotations.outline.strokeWidth + theme.annotations.outline.outlineWidth * 2\n            ctx.beginPath()\n            ctx.arc(annotation.x, annotation.y, annotation.size / 2, 0, 2 * Math.PI)\n            ctx.stroke()\n        }\n\n        if (isDotAnnotation(annotation) && theme.annotations.symbol.outlineWidth > 0) {\n            ctx.strokeStyle = theme.annotations.symbol.outlineColor\n            ctx.lineWidth = theme.annotations.symbol.outlineWidth * 2\n            ctx.beginPath()\n            ctx.arc(annotation.x, annotation.y, annotation.size / 2, 0, 2 * Math.PI)\n            ctx.stroke()\n        }\n\n        if (isRectAnnotation(annotation) && theme.annotations.outline.outlineWidth > 0) {\n            ctx.strokeStyle = theme.annotations.outline.outlineColor\n            ctx.lineWidth =\n                theme.annotations.outline.strokeWidth + theme.annotations.outline.outlineWidth * 2\n            ctx.beginPath()\n            ctx.rect(\n                annotation.x - annotation.width / 2,\n                annotation.y - annotation.height / 2,\n                annotation.width,\n                annotation.height\n            )\n            ctx.stroke()\n        }\n\n        ctx.strokeStyle = theme.annotations.link.stroke\n        ctx.lineWidth = theme.annotations.link.strokeWidth\n        ctx.beginPath()\n        drawPoints(ctx, annotation.computed.points)\n        ctx.stroke()\n\n        if (isCircleAnnotation(annotation)) {\n            ctx.strokeStyle = theme.annotations.outline.stroke\n            ctx.lineWidth = theme.annotations.outline.strokeWidth\n            ctx.beginPath()\n            ctx.arc(annotation.x, annotation.y, annotation.size / 2, 0, 2 * Math.PI)\n            ctx.stroke()\n        }\n\n        if (isDotAnnotation(annotation)) {\n            ctx.fillStyle = theme.annotations.symbol.fill\n            ctx.beginPath()\n            ctx.arc(annotation.x, annotation.y, annotation.size / 2, 0, 2 * Math.PI)\n            ctx.fill()\n        }\n\n        if (isRectAnnotation(annotation)) {\n            ctx.strokeStyle = theme.annotations.outline.stroke\n            ctx.lineWidth = theme.annotations.outline.strokeWidth\n            ctx.beginPath()\n            ctx.rect(\n                annotation.x - annotation.width / 2,\n                annotation.y - annotation.height / 2,\n                annotation.width,\n                annotation.height\n            )\n            ctx.stroke()\n        }\n\n        if (typeof annotation.note === 'function') {\n            annotation.note(ctx, {\n                datum: annotation.datum,\n                x: annotation.computed.text[0],\n                y: annotation.computed.text[1],\n                theme,\n            })\n        } else {\n            ctx.font = `${theme.annotations.text.fontSize}px ${theme.annotations.text.fontFamily}`\n            ctx.textAlign = 'left'\n            ctx.textBaseline = 'alphabetic'\n\n            ctx.fillStyle = theme.annotations.text.fill\n            ctx.strokeStyle = theme.annotations.text.outlineColor\n            ctx.lineWidth = theme.annotations.text.outlineWidth * 2\n\n            if (theme.annotations.text.outlineWidth > 0) {\n                ctx.lineJoin = 'round'\n                ctx.strokeText(\n                    annotation.note,\n                    annotation.computed.text[0],\n                    annotation.computed.text[1]\n                )\n                ctx.lineJoin = 'miter'\n            }\n            ctx.fillText(annotation.note, annotation.computed.text[0], annotation.computed.text[1])\n        }\n    })\n    ctx.restore()\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}